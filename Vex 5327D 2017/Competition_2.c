#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Motor,  port2,           baseLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           baseRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           baseLeftBack,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           baseRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           dr4bLeftUp,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           dr4bRightUp,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           dr4bLeftDown,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           dr4bRightDown, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*When utilizing the MotorSlewRateTask, make sure to name/define your motors according to its index*/

/*
for the motor index:
0 = baseLeftFront
1 = baseRightFront
2 = baseLeftBack
3 = baseRightBack
4 = dr4bLeftUp
5 = dr4bRightUp
6 = dr4bLeftDown
7 = dr4bRightDown
*/


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  definitiona and variables for the motor slew rate controller.              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#define MOTOR_NUM               kNumbOfTotalMotors  //number of total motors (applied to all)
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev (increase 10 every time looped through)
#define MOTOR_FAST_SLEW_RATE    256     // essentially off (need to be changed to between -127 to 127)
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
// This array will have the number of objects equivalent to MOTOR_NUM
// The value in this array will need to be modified in order for the motors to move
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Task  - compares the requested speed of each motor to the current speed    */
/*          and increments or decrements to reduce the difference as necessary */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task MotorSlewRateTask()
{
    int motorIndex; //The index for each motor
    int motorTmp;  //The current motor value for each motor, to be changed to change motor speed

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            // current motor value
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                //if motor value in the list is greater than motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    //if motor value is greater than motor value in the list
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}

task slewBase ()
{
	/*this task is to move the corresponding value of the motors for the base in motorReq array
	in order to work in unison with the MotorSlewRateTask task*/
  while (true)
  {
  	//Index 1 & 3 are right base motors
		motorReq[ 1 ] = motorReq[ 3 ] = vexRT[Ch2];
  	//Index 0 & 2 are left base motors
		motorReq[ 0 ] = motorReq[ 2 ] = vexRT[Ch3];
		wait1Msec (25); //40Hz
	}
}

/*-------------------------------------------------------------------------------------------------------------*/
// PID using potentiometer
//
// potentiometer returns a value between 0 and 4095
//

/*when the joystick is being moved, the pidRequestedValue is being accumulated
while the PID controller is doing calculations, and moving the motor to the pidRequestedValue,
the pidController should allow the motor to stop percisely at the pidRequested Value unless the joystick
is moved.*/

/*for specific application to certain parts of the robot, try to adjust the pid_Kp, pid_Ki, pid_Kd constants
to use the pidController to its full potential.*/

#define PID_SENSOR_INDEX    potentiometer
#define PID_SENSOR_SCALE    1

#define PID_MOTOR_1_INDEX   dr4bLeftUp
#define PID_MOTOR_2_INDEX   dr4bRightUp
#define PID_MOTOR_3_INDEX   dr4bLeftDown
#define PID_MOTOR_4_INDEX   dr4bRightDown
#define PID_MOTOR_SCALE     -1

#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)

#define PID_INTEGRAL_LIMIT  50  //this is meant to set a controllable window for PID to integrate error

/* These could be constants but leaving
as variables allows them to be modified in the debugger "live"*/
/*these constant are to be left out here for tuning,
you can adjust the constants to make the PID controller work better*/
float  pid_Kp = 2.0;
float  pid_Ki = 0.04;
float  pid_Kd = 0.0;

/*static variables will have its value defined only once*/
static int   pidRunning = 1;
static float pidRequestedValue;

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task pidController()
{
	float  pidSensorCurrentValue;

	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	// If we are using a potentiometer then clear it
	if( SensorType[ PID_SENSOR_INDEX ] == sensorPotentiometer )
	{
		SensorValue[ PID_SENSOR_INDEX ] = 0;
	}

	// Init the variables
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Is PID control active ? int 1 substitutes for true
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX ] * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - pidRequestedValue;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
      {
				// If we are inside controlable window then integrate the error
        if( abs(pidError) < PID_INTEGRAL_LIMIT )
      	{
      		pidIntegral = pidIntegral + pidError;
      	}
      	else
        {
     			pidIntegral = 0;
     		}
			}
			else
			{
				pidIntegral = 0;
			}

			// calculate the derivative
			/*dirivative is the rate of change of slope, where slope is created by the change of error over time*/
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			/*pidError can also be intepreted as "pidProportional"*/
      pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive, because max is 127, and min is -127
			if( pidDrive > PID_DRIVE_MAX )
			{
				pidDrive = PID_DRIVE_MAX;
			}
			if( pidDrive < PID_DRIVE_MIN )
			{
				pidDrive = PID_DRIVE_MIN;
			}

      // send to motors
			motor[ PID_MOTOR_1_INDEX ] = pidDrive * PID_MOTOR_SCALE;
      motor[ PID_MOTOR_2_INDEX ] = pidDrive * PID_MOTOR_SCALE;
      motor[ PID_MOTOR_3_INDEX ] = pidDrive * PID_MOTOR_SCALE;
      motor[ PID_MOTOR_4_INDEX ] = pidDrive * PID_MOTOR_SCALE;
		}
		/*"else" will run if "static int pidRunning = 1;" is not defined by startTask()*/
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			motor[ PID_MOTOR_1_INDEX ] = 0;
      motor[ PID_MOTOR_2_INDEX ] = 0;
      motor[ PID_MOTOR_3_INDEX ] = 0;
      motor[ PID_MOTOR_4_INDEX ] = 0;
		}

   	// Run at 50Hz, or 50 times per second
    wait1Msec( 25 );
	}
}

task pidLift()
{
	// use Btn5U, Btn5D to modify the pidRequestedValue

	while( true )
	{
		/*the default internal motor gearing is 100 rpm,
		high speed is 160 rpm, and turbo is 240 rpm*/

		/*with an external gear ratio of 1:7, and the default internal gear ratio with 100rpm,
		100/7/60*360*(4095/270) = 1300, the pidRequestedValue should be moving at a rate of
		1300 counts per second*/
		if (vexRT[Btn5U] == 1)
	  {
	  	//since this task is running at 50 Hz, and pidRequestedValue is moving at 1300 counts per second
	  	pidRequestedValue = pidRequestedValue + (1300/50);
	  }
	  else if (vexRT[Btn5D] == 1)
	  {
	  	pidRequestedValue = pidRequestedValue - (1300/50);
	  }
	  else
	  {
	  	pidRequestedValue = pidRequestedValue;
	  }

		wait1Msec(25); //40Hz
	}
}

task slewLift()
{
	while (true)
	{
		if (vexRT[Btn5U] == 1)
		{
			motorReq[ 4 ] = motor[ PID_MOTOR_1_INDEX ];
			motorReq[ 5 ] = motor[ PID_MOTOR_2_INDEX ];
			motorReq[ 6 ] = motor[ PID_MOTOR_3_INDEX ];
			motorReq[ 7 ] = motor[ PID_MOTOR_4_INDEX ];
		}
	}
}


task main ()
{
	startTask(MotorSlewRateTask);
	startTask(slewBase); //utilizing slew rate on base
	startTask(slewLift); //utilizing slew rate on rd4b

	//initializing a random value, doesn't matter
	pidRequestedValue = 1000;
	// start the PID task
	startTask( pidController );
	startTask( pidLift );
}
