#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, in2,    wrist_pot,      sensorPotentiometer)
#pragma config(Sensor, in3,    auto_pot,       sensorPotentiometer)
#pragma config(Motor,  port1,           back_left,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           back_right,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           front_right,   tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift_bottom_left, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift_top_left, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift_top_right, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lift_bottom_right, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           grabber_grab,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           grabber_turn,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          front_left,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define GRAB_OPEN 350
#define GRAB_SKYRISE 250
#define GRAB_CLOSE 3500

#define WRIST_UP 300
#define WRIST_LEVEL 1500
#define WRIST_DOWN 2100




#define BLUE_SKYRISE_LOW 75
#define BLUE_SKYRISE_HIGH 1125
#define BLUE_POST_LOW 1125
#define BLUE_POST_HIGH 2275

#define RED_POST_LOW 2275
#define RED_POST_HIGH 3045
#define RED_SKYRISE_LOW 3045
#define RED_SKYRISE_HIGH 3715

#define DISABLED_LOW 3715
#define DISABLED_HIGH 4095




/*
Slew Rate Limiting code
*/

#define MOTOR_NUM               10
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Task  - compares the requested speed of each motor to the current speed    */
/*          and increments or decrements to reduce the difference as nexessary */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}

/*
End of Slew Rate Limiting code
*/



//float currentPosition = 0;
//float oldPosition = 250;
//float positionError = 0;
//float currentTime = 0;
//float oldTime = 0;
//float currentSpeed = 0;
//float speedError = 0;
//float kd = 10;
//float kp = 0.4;
//float desiredSpeed = 0;
//float maxVelocity = 0;
//float leastVelocity = 0;
//int desiredPosition = 2000;
//int current = 0;
//int velocityControl = 0;
//int positionControl = 0;
//int counter = 0;

int currentPosition = 0;
int desiredPosition = 2000;
//int bottomPositionThreshold = 100;
//int topPositionThreshold = 20;
//float staticCurrent = -127;
//float staticReverseCurrent = 7;
float kd = 0.4;
float current = 0;
float positionError = 0;
int overrideVal = 0;
int maxCurrent = 80;

int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

void runLift(int speed) {
	motorReq[lift_bottom_left] = speed;
	motorReq[lift_bottom_right] = speed;
	motorReq[lift_top_left] = speed;
	motorReq[lift_top_right] = speed;
}

task PID() {
	clearTimer(T1);
	while (true) {

		//manual override buttons
		if (vexRT[Btn7U]) {
			overrideVal++;
		} else if (vexRT[Btn7D]) {
			overrideVal--;
		}

		currentPosition = SensorValue[pot];
		positionError = ((desiredPosition + overrideVal) - currentPosition);
		//if (abs(positionError) > topPositionThreshold) {
		//	if (currentPosition < desiredPosition) {
		//		 runLift(staticCurrent);
		//	} else {
		  	 //runLift(staticReverseCurrent);
		//  }
		//}
		//else {
			current = kd * positionError;
			if (current > maxCurrent) {
				runLift(maxCurrent);
			} else if (current < -maxCurrent) {
				runLift(-maxCurrent);
			} else {
				runLift(current);
			}

		//}

		//currentPosition = SensorValue[pot];
		//positionError = desiredPosition - SensorValue[pot];
		//currentTime = time1[T1];
		//currentSpeed = (currentPosition - oldPosition) / (currentTime - oldTime);
		//speedError = desiredSpeed - currentSpeed;
		//velocityControl = (int)(kd * speedError);
		//positionControl = (int)(kp * positionError);
		//current = positionControl - velocityControl;

		//counter++;

		//lift(current);

		//oldPosition = currentPosition;
		//oldTime = currentTime;

		//if (currentSpeed > maxVelocity) {
		//	maxVelocity = currentSpeed;
		//}

		//if (currentSpeed < leastVelocity) {
		//	leastVelocity = currentSpeed;
		//}

		//if ((counter % 1000) == 0) {
		//	desiredPosition = random(1500) + 200;
		//}

    wait1Msec(5);
	}
}

////grab PID vars
//int grab;
//int grabError;
//float grabGain = 0.1;
//int grabCurrent;
//int desiredGrab = GRAB_OPEN;

//task grabPID() {
//	while (true) {

//		grab = SensorValue[grab_pot];
//		grabError = desiredGrab - grab;
//		grabCurrent = (int)(grabGain * grabError);
//		motorReq[grabber_grab] = grabCurrent;

//		wait1Msec(5);
//	}
//}

//wrist PID vars
int wrist;
float wristError;
float wristGain = 0.1;
int wristCurrent;
int desiredWrist = WRIST_UP;

task wristPID() {
	while (true) {

		wrist = SensorValue[wrist_pot];
		wristError = desiredWrist - wrist;
		wristCurrent = (int)(wristGain * wristError);
		motorReq[grabber_turn] = wristCurrent;

		wait1Msec(5);
	}
}

int liftArrayIndex = 0;
int liftPositions[4] = {
	1100,
	1700,
	2000,
	2400
};
//int liftPositionThreshold = 15;

task changeLiftPosition() {
	while (true) {
		//if (!((currentPosition > (liftPositions[liftArrayIndex] + liftPositionThreshold)) || (currentPosition < (liftPositions[liftArrayIndex] - liftPositionThreshold)))) {
		if (vexRT[Btn6U] && desiredPosition < 2400) {
				//overrideVal = 0;
				//liftArrayIndex = liftArrayIndex + 1;
				desiredPosition += 5;
		}
		if (vexRT[Btn6D] && desiredPosition > 300) {
				//overrideVal = 0;
				//liftArrayIndex = liftArrayIndex - 1;
				desiredPosition -= 5;
		}

		//desiredPosition = liftPositions[liftArrayIndex];

		wait1Msec(5);
	}
}



//FUNCTIONS**********************************************************************************
void driveForward(int speed) {
	motorReq[front_right] = speed;
	motorReq[front_left] = speed;
	motorReq[back_right] = speed;
	motorReq[back_left] = speed;
}

//positive: left
void driveSideways(int speed) {
	motorReq[back_left] = speed;
	motorReq[back_right] = -speed;
	motorReq[front_left] = -speed;
	motorReq[front_right] = speed;
}

//positive: counterclockwise
void rotate(int speed) {
	motorReq[back_left] = speed;
	motorReq[back_right] = -speed;
	motorReq[front_left] = speed;
	motorReq[front_right] = -speed;
}
//END FUNCTIONS*****************************************************************************



bool lastButton = false; //false is lat open; true is last closed

//pre autonomous
void pre_auton() {
	bStopTasksBetweenModes = true;
	nMotorEncoder[back_left] = 0;
}

int lastEncValue = 0;

task autonomous() {
	if (!(SensorValue[auto_pot] > DISABLED_LOW && Sensorvalue[auto_pot] < DISABLED_HIGH)) {
		startTask(PID);
		startTask(wristPID);
		startTask(changeLiftPosition);
		startTask(MotorSlewRateTask);

		if (SensorValue[auto_pot] > BLUE_SKYRISE_LOW && SensorValue[auto_pot] < BLUE_SKYRISE_HIGH) {
			//BLUE SKYRISE CODE

			//drive backward so that a cube is placed onto the skyrise post
			driveForward(-100);
			wait1Msec(2000);
			driveForward(0);
			//END BLUE SKYRISE CODE
		} else if (SensorValue[auto_pot] > BLUE_POST_LOW && SensorValue[auto_pot] < BLUE_POST_HIGH) {
			//BLUE POST CODE

			//wait for lift to go up to default position pushing the cube onto the post
			wait1Msec(750);
			//move froward
			driveForward(100);
			wait1Msec(1250);
			driveForward(0);
			wait1Msec(500);
			//turn 45 degrees clockwise
			rotate(-100);
			wait1Msec(500);
			rotate(0);
			wait1Msec(500);
			//drive forward
			driveForward(100);
			wait1Msec(1425);
			driveForward(0);
			wait1Msec(500);
			//turn 45 degrees counterclockwise
			rotate(100);
			wait1Msec(375);
			rotate(0);
			wait1Msec(500);
			//backup into cube and wall
			driveForward(-100);
			wait1Msec(2750);
			driveForward(0);
			wait1Msec(500);
			//move forward so that i stop touching the cube
			driveForward(100);
			wait1Msec(2000);
			driveForward(0);

			//END BLUE POST CODE
		} else if (SensorValue[auto_pot] > RED_SKYRISE_LOW && SensorValue[auto_pot] < RED_SKYRISE_HIGH) {
			//RED SKYRISE CODE

			//drive backward so that the preload is tilted onto the skyrise base
			driveForward(-100);
			wait1Msec(750);
			driveForward(0);

			//END BLUE SKYRISE CODE
		} else if (SensorValue[auto_pot] > RED_POST_LOW && SensorValue[auto_pot] < RED_POST_HIGH) {
			//RED POST CODE

			//wait for lift to go up to default position pushing the cube onto the post
			wait1Msec(750);
			//move froward
			driveForward(100);
			wait1Msec(1250);
			driveForward(0);
			wait1Msec(500);
			//turn 45 degrees clockwise
			rotate(100);
			wait1Msec(500);
			rotate(0);
			wait1Msec(500);
			//drive forward
			driveForward(100);
			wait1Msec(1425);
			driveForward(0);
			wait1Msec(500);
			//turn 45 degrees counterclockwise
			rotate(-100);
			wait1Msec(375);
			rotate(0);
			wait1Msec(500);
			//backup into cube and wall
			driveForward(-100);
			wait1Msec(2750);
			driveForward(0);
			wait1Msec(500);
			//move forward so that i stop touching the cube
			driveForward(100);
			wait1Msec(750);
			driveForward(0);

			//END RED POST CODE
		}

		//autonomous
		////wait for lift to go up to default position pushing the cube onto the post
		//wait1Msec(750);
		////move froward
		//driveForward(100);
		//wait1Msec(1250);
		//driveForward(0);
		//wait1Msec(500);
		////turn 45 degrees clockwise
		//rotate(100);
		//wait1Msec(750);
		//rotate(0);
		//wait1Msec(500);
		////drive forward
		//driveForward(100);
		//wait1Msec(1425);
		//driveForward(0);
		//wait1Msec(500);
		////turn 45 degrees counterclockwise
		//rotate(-100);
		//wait1Msec(400);
		//rotate(0);
		//wait1Msec(500);
		////backup into cube and wall
		//driveForward(-100);
		//wait1Msec(2750);
		//driveForward(0);
		//wait1Msec(500);
		////move forward so that i stop touching the cube
		//driveForward(100);
		//wait1Msec(750);
		//driveForward(0);
	}



	//nMotorEncoder[back_left] = 0;

	////while (nMotorEncoder[back_left] < 175) {
	////	driveForward(-60);
	////}

	////driveForward(0);
	////nMotorEncoder[back_left] = 0;

	////while (nMotorEncoder[back_left] > -250) {
	////	driveForward(60);
	////	if ((nMotorEncoder[back_left] < -200) && ((nMotorEncoder[back_left] - lastEncValue) == 0)) {
	////		break;
	////	}
	////	wait1Msec(10);
	////	lastEncValue = nMotorEncoder[back_left];
	////}

	////driveForward(0);

	//liftArrayIndex = 3;

	//wait1Msec(5000);

	////while (SensorValue[skyrise] == 0) {
	////	driveSideways(-100);
	////}

	////driveSideways(0);
	////nMotorEncoder[back_left] = 0;

	////while (nMotorEncoder[back_left] > -120) {
	////	driveSideways(100);
	////}

	////driveSideways(0);
	////nMotorEncoder[back_left] = 0;

	////driveForward(100);
	////wait1Msec(250);
	////driveForward(0);

	////driveForward(-100);
	////wait1Msec(1000);
	////driveForward(0);

	//desiredWrist = WRIST_LEVEL;
	//liftArrayIndex = 1;
	//overrideVal = -85;

	//wait1Msec(600);

	//while (SensorValue[close_gripper] == 0) {
	//	driveForward(40);
	//}

	//driveForward(0);
	//nMotorEncoder[back_left] = 0;

	//motorReq[grabber_grab] = 40;
	//liftArrayIndex = 2;

	//wait1Msec(500);

	//while (nMotorEncoder[back_left] > -500) {
	//	driveSideways(100);
	//}
}

task usercontrol() {
	startTask(PID);
	startTask(wristPID);
	startTask(changeLiftPosition);
	startTask(MotorSlewRateTask);
	while(true) {

		//Create "deadzone" for Y1/Ch3
    if(abs(vexRT[Ch3]) > threshold)
      Y1 = vexRT[Ch3];
    else
      Y1 = 0;
    //Create "deadzone" for X1/Ch4
    if(abs(vexRT[Ch4]) > threshold)
      X2 = vexRT[Ch4];
    else
      X2 = 0;
    //Create "deadzone" for X2/Ch1
    if(abs(vexRT[Ch1]) > threshold)
      X1 = vexRT[Ch1];
    else
      X1 = 0;

    //Remote Control Commands
    motorReq[front_right] = Y1 - X2 - X1;
    motorReq[back_right] =  Y1 - X2 + X1;
    motorReq[front_left] = Y1 + X2 + X1;
    motorReq[back_left] =  Y1 + X2 - X1;

   // if (vexRT[Btn6U] && ((desiredWrist < WRIST_UP) && (desiredWrist > WRIST_DOWN)))
   // 	desiredWrist++;
  	//}

  	//if (vexRT[Btn6D] && ((desiredWrist < WRIST_UP) && (desiredWrist > WRIST_DOWN))) {
   // 	desiredWrist--;
  	//}

    if (lastButton) {
  		motorReq[grabber_grab] = 80;
  	} else {
  		motorReq[grabber_grab] = 0;
  	}

    if (vexRT[Btn8U] && (desiredWrist > WRIST_UP)) {
    	desiredWrist-=20;
  	}

  	if (vexRT[Btn8D] && (desiredWrist < WRIST_DOWN)) {
    	desiredWrist+=20;
  	}

  	if (wrist > WRIST_DOWN) {
  		desiredWrist = WRIST_LEVEL;
  	} else if (wrist < WRIST_UP) {
  		desiredWrist = WRIST_LEVEL;
  	}

  	if (vexRT[Btn7R]) {
  		motorReq[grabber_grab] = 100;
  		lastButton = true;
  	}

  	if (vexRT[Btn7L]) {
  		motorReq[grabber_grab] = -100;
  		lastButton = false;
  	}

		wait1Msec(10);
	}
